<html>
<head>
<title> Python </title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="keywords" content="Mastering Responsive web template, Bootstrap Web Templates, Flat Web Templates, Android Compatible web template, 
Smartphone Compatible web template, free webdesigns for Nokia, Samsung, LG, SonyEricsson, Motorola web design" />
<script type="application/x-javascript"> addEventListener("load", function() { setTimeout(hideURLbar, 0); }, false);
		function hideURLbar(){ window.scrollTo(0,1); } </script>
<!-- //custom-theme -->
<link href="../static/css/bootstrap.css" rel="stylesheet" type="text/css" media="all" />
<link href="../static/css/JiSlider.css" rel="stylesheet"> 
<link rel="stylesheet" href="../static/css/flexslider.css" type="text/css" media="screen" property="" />

<link href="../static/css/style.css" rel="stylesheet" type="text/css" media="all" />

<!-- font-awesome-icons -->
<link href="../static/css/font-awesome.css" rel="stylesheet"> 
<!-- //font-awesome-icons -->
<link href="//fonts.googleapis.com/css?family=Raleway:400,400i,500,500i,600,600i,700,700i,800" rel="stylesheet">
<link href='//fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>

	<link rel="stylesheet" href="../../static/css/login.css">
	<style>
		h3{
		font-family:montserrat;
			text-decoration: underline black;
			color:blue;
			}
		</style>
</head>
<body style="background-color:white;" >


<img src="../static/images/ds.png" width="100%" height="100%" >
<div class="container">
<br><br>
<h3> DATA STRUCTURE AND ALGORITHM</h3>
<br><h3>Data Structures Tutorial</h3>
 
Data Structures (DS) tutorial provides basic and advanced concepts of Data Structure. Our Data Structure tutorial is designed for beginners and professionals.<br>
Data Structure is a way to store and organize data so that it can be used efficiently.<br>
Our Data Structure tutorial includes all topics of Data Structure such as Array, Pointer, Structure, Linked List, Stack, Queue, Graph, Searching, Sorting, Programs, etc.<br>
<br><h3>What is Data Structure?</h3>
The data structure name indicates itself that organizing the data in memory. There are many ways of organizing the data in the memory as we have already seen one of the data structures, i.e., array in C language. Array is a collection of memory elements in which data is stored sequentially, i.e., one after another. In other words, we can say that array stores the elements in a continuous manner. This organization of data is done with the help of an array of data structures. There are also other ways to organize the data in memory. Let's see the different types of data structures.
<br>The data structure is not any programming language like C, C++, java, etc. It is a set of algorithms that we can use in any programming language to structure the data in the memory.
<br>To structure the data in memory, 'n' number of algorithms were proposed, and all these algorithms are known as Abstract data types. These abstract data types are the set of rules.
 <br>
<br><h3>Types of Data Structures</h3>
There are two types of data structures:<br>
<b>o</b> Primitive data structure<br>
<b>o</b> Non-primitive data structure<br>
<br><h3>Primitive Data structure</h3>
The primitive data structures are primitive data types. The int, char, float, double, and pointer are the primitive data structures that can hold a single value.<br>
Non-Primitive Data structure<br>
<br><h3>The non-primitive data structure is divided into two types:</h3>
<b>o</b> Linear data structure<br>
<b>o</b> Non-linear data structure<br>
<br><h3>Linear Data Structure</h3>
The arrangement of data in a sequential manner is known as a linear data structure. The data structures used for this purpose are Arrays, Linked list, Stacks, and Queues. In these data structures, one element is connected to only one another element in a linear form.
<br>When one element is connected to the 'n' number of elements known as a non-linear data structure. The best example is trees and graphs. In this case, the elements are arranged in a random manner.
<br>We will discuss the above data structures in brief in the coming topics. Now, we will see the common operations that we can perform on these data structures.
<br>Data structures can also be classified as:<br>
<b>o</b> Static data structure: It is a type of data structure where the size is allocated at the compile time. Therefore, the maximum size is fixed.<br>
<b>o</b> Dynamic data structure: It is a type of data structure where the size is allocated at the run time. Therefore, the maximum size is flexible.<br>
<br><h3>Major Operations </h3>
The major or the common operations that can be performed on the data structures are:<br>
<b>o</b> Searching: We can search for any element in a data structure.<br>
<b>o</b> Sorting: We can sort the elements of a data structure either in an ascending or descending order.<br>
<b>o</b> Insertion: We can also insert the new element in a data structure.<br>
<b>o</b> Updation: We can also update the element, i.e., we can replace the element with another element.<br>
<b>o</b> Deletion: We can also perform the delete operation to remove the element from the data structure.<br>
<br><h3>Which Data Structure?</h3>
A data structure is a way of organizing the data so that it can be used efficiently. Here, we have used the word efficiently, which in terms of both the space and time. <br>For example, a stack is an ADT (Abstract data type) which uses either arrays or linked list data structure for the implementation. Therefore, we conclude that we require some data structure to implement a particular ADT.
An ADT tells what is to be done and data structure tells how it is to be done. In other words, we can say that ADT gives us the blueprint while data structure provides the implementation part. Now the question arises: how can one get to know which data structure to be used for a particular ADT?.
As the different data structures can be implemented in a particular ADT, but the different implementations are compared for time and space. For example, the Stack ADT can be implemented by both Arrays and linked list. Suppose the array is providing time efficiency while the linked list is providing space efficiency, so the one which is the best suited for the current user's requirements will be selected.
<br><br><h3>Advantages of Data structures</h3>
The following are the advantages of a data structure:<br>
<b>o</b> Efficiency: If the choice of a data structure for implementing a particular ADT is proper, it makes the program very efficient in terms of time and space.<br>
<b>o</b> Reusability: he data structures provide reusability means that multiple client programs can use the data structure.<br>
<b>o</b> Abstraction: The data structure specified by an ADT also provides the level of abstraction. The client cannot see the internal working of the data structure, so it does not have to worry about the implementation part. The client can only see the interface.
DS Algorithm<br>
<br><h3>What is an Algorithm?</h3>
An algorithm is a process or a set of rules required to perform calculations or some other problem-solving operations especially by a computer. The formal definition of an algorithm is that it contains the finite set of instructions which are being carried in a specific order to perform the specific task. It is not the complete program or code; it is just a solution (logic) of a problem, which can be represented either as an informal description using a Flowchart or Pseudocode.
<br>Characteristics of an Algorithm<br>
The following are the characteristics of an algorithm:<br>
<b>o</b> Input: An algorithm has some input values. We can pass 0 or some input value to an algorithm.<br>
<b>o</b> Output: We will get 1 or more output at the end of an algorithm.<br>
<b>o</b> Unambiguity: An algorithm should be unambiguous which means that the instructions in an algorithm should be clear and simple.<br>
<br><b>o</b> Finiteness: An algorithm should have finiteness. Here, finiteness means that the algorithm should contain a limited number of instructions, i.e., the instructions should be countable.
<b>o</b> Effectiveness: An algorithm should be effective as each instruction in an algorithm affects the overall process.<br>
<b>o</b> Language independent: An algorithm must be language-independent so that the instructions in an algorithm can be implemented in any of the languages with the same output.<br>
<br><h3>Factors of an Algorithm</h3>
The following are the factors that we need to consider for designing an algorithm:<br>
<b>o</b> Modularity: If any problem is given and we can break that problem into small-small modules or small-small steps, which is a basic definition of an algorithm, it means that this feature has been perfectly designed for the algorithm.<br>
<b>o</b> Correctness: The correctness of an algorithm is defined as when the given inputs produce the desired output, which means that the algorithm has been designed algorithm. The analysis of an algorithm has been done correctly.<br>
<b>o</b> Maintainability: Here, maintainability means that the algorithm should be designed in a very simple structured way so that when we redefine the algorithm, no major change will be done in the algorithm.<br>
<b>o</b> Functionality: It considers various logical steps to solve the real-world problem.<br>
<b>o</b> Robustness: Robustness means that how an algorithm can clearly define our problem.<br>
<b>o</b> User-friendly: If the algorithm is not user-friendly, then the designer will not be able to explain it to the programmer.<br>
<b>o</b> Simplicity: If the algorithm is simple then it is easy to understand.<br>
<b>o</b> Extensibility: If any other algorithm designer or programmer wants to use your algorithm then it should be extensible.<br>
<br><h3>Importance of Algorithms</h3>
1.	Theoretical importance: When any real-world problem is given to us and we break the problem into small-small modules. To break down the problem, we should know all the theoretical aspects.
<br>2.	Practical importance: As we know that theory cannot be completed without the practical implementation. So, the importance of algorithm can be considered as both theoretical and practical.
<br><br><h3>Issues of Algorithms</h3>
The following are the issues that come while designing an algorithm:<br>
<b>o</b>How to design algorithms: As we know that an algorithm is a step-by-step procedure so we must follow some steps to design an algorithm.<br>
<b>o</b>How to analyze algorithm efficiency<br>
<br><h3>Approaches of Algorithm</h3>
The following are the approaches used after considering both the theoretical and practical importance of designing an algorithm:<br>
<br><b>o</b>Brute force algorithm: The general logic structure is applied to design an algorithm. It is also known as an exhaustive search algorithm that searches all the possibilities to provide the required solution. Such algorithms are of two types:
<br>1.	Optimizing: Finding all the solutions of a problem and then take out the best solution or if the value of the best solution is known then it will terminate if the best solution is known.
<br>2.	Sacrificing: As soon as the best solution is found, then it will stop.
<br><b>o</b>Divide and conquer: It is a very implementation of an algorithm. It allows you to design an algorithm in a step-by-step variation. It breaks down the algorithm to solve the problem in different methods. It allows you to break down the problem into different methods, and valid output is produced for the valid input. This valid output is passed to some other function.
<br><b>o</b>Greedy algorithm: It is an algorithm paradigm that makes an optimal choice on each iteration with the hope of getting the best solution. It is easy to implement and has a faster execution time. But, there are very rare cases in which it provides the optimal solution.
<br><b>o</b>Dynamic programming: It makes the algorithm more efficient by storing the intermediate results. It follows five different steps to find the optimal solution for the problem:
<br>1.	It breaks down the problem into a subproblem to find the optimal solution.
<br><br>2.	After breaking down the problem, it finds the optimal solution out of these subproblems.
<br>3.	Stores the result of the subproblems is known as memorization.
<br>4.	Reuse the result so that it cannot be recomputed for the same subproblems.
<br>5.	Finally, it computes the result of the complex program.
<br><b>o</b>Branch and Bound Algorithm: The branch and bound algorithm can be applied to only integer programming problems. This approach divides all the sets of feasible solutions into smaller subsets. These subsets are further evaluated to find the best solution.
<br><b>o</b>Randomized Algorithm: As we have seen in a regular algorithm, we have predefined input and required output. Those algorithms that have some defined set of inputs and required output, and follow some described steps are known as deterministic algorithms. What happens that when the random variable is introduced in the randomized algorithm?. In a randomized algorithm, some random bits are introduced by the algorithm and added in the input to produce the output, which is random in nature. Randomized algorithms are simpler and efficient than the deterministic algorithm.
<br><b>o</b>Backtracking: Backtracking is an algorithmic technique that solves the problem recursively and removes the solution if it does not satisfy the constraints of a problem.
<br><br><h3>The major categories of algorithms are given below:</h4>
<br><b>o</b>Sort: Algorithm developed for sorting the items in a certain order.
<br><b>o</b>Search: Algorithm developed for searching the items inside a data structure.
<br><b>o</b>Delete: Algorithm developed for deleting the existing element from the data structure.
<br><b>o</b>Insert: Algorithm developed for inserting an item inside a data structure.
<br><b>o</b>Update: Algorithm developed for updating the existing element inside a data structure.<br>
<br><h3>Algorithm Analysis</h3>
The algorithm can be analyzed in two levels, i.e., first is before creating the algorithm, and second is after creating the algorithm. The following are the two analysis of an algorithm:
<br><b>o</b>Priori Analysis: Here, priori analysis is the theoretical analysis of an algorithm which is done before implementing the algorithm. Various factors can be considered before implementing the algorithm like processor speed, which has no effect on the implementation part.
<br><b>o</b>Posterior Analysis: Here, posterior analysis is a practical analysis of an algorithm. The practical analysis is achieved by implementing the algorithm using any programming language. This analysis basically evaluate that how much running time and space taken by the algorithm.
<br><br><h3>Algorithm Complexity</h3>
The performance of the algorithm can be measured in two factors:<br>
<br><b>o</b>Time complexity: The time complexity of an algorithm is the amount of time required to complete the execution. The time complexity of an algorithm is denoted by the big O notation. Here, big O notation is the asymptotic notation to represent the time complexity. The time complexity is mainly calculated by counting the number of steps to finish the execution. Let's understand the time complexity through an example.
<br>1.	sum=0;  
<br>2.	// Suppose we have to calculate the sum of n numbers.  
<br>3.	for i=1 to n  
<br>4.	sum=sum+i;  
<br>5.	// when the loop ends then sum holds the sum of the n numbers  
<br>6.	return sum;  
<br>In the above code, the time complexity of the loop statement will be atleast n, and if the value of n increases, then the time complexity also increases. While the complexity of the code, i.e., return sum will be constant as its value is not dependent on the value of n and will provide the result in one step only. We generally consider the worst-time complexity as it is the maximum time taken for any given input size.
<br><b>o</b>Space complexity: An algorithm's space complexity is the amount of space required to solve a problem and produce an output. Similar to the time complexity, space complexity is also expressed in big O notation.
<br>For an algorithm, the space is required for the following purposes:
<br>1.	To store program instructions
<br>2.	To store constant values
<br>3.	To store variable values
<br>4.	To track the function calls, jumping statements, etc.<br>
Auxiliary space: The extra space required by the algorithm, excluding the input size, is known as an auxiliary space. The space complexity considers both the spaces, i.e., auxiliary space, and space used by the input.
So,<br>
Space complexity = Auxiliary space + Input size.<br>
<br><h3>Types of Algorithms</h3>
The following are the types of algorithm:<br>
<b>o</b>Search Algorithm<br>
<b>o</b>Sort Algorithm<br>
<br><h3>Search Algorithm</h3>
On each day, we search for something in our day to day life. Similarly, with the case of computer, huge data is stored in a computer that whenever the user asks for any data then the computer searches for that data in the memory and provides that data to the user. There are mainly two techniques available to search the data in an array:
<br><b>o</b>Linear search<br>
<b>o</b>Binary search<br>
<b>Linear Search</b><br>
Linear search is a very simple algorithm that starts searching for an element or a value from the beginning of an array until the required element is not found. It compares the element to be searched with all the elements in an array, if the match is found, then it returns the index of the element else it returns -1. This algorithm can be implemented on the unsorted list.
<br><b>Binary Search</b><br>
<br>A Binary algorithm is the simplest algorithm that searches the element very quickly. It is used to search the element from the sorted list. The elements must be stored in sequential order or the sorted manner to implement the binary algorithm. Binary search cannot be implemented if the elements are stored in a random manner. It is used to find the middle element of the list.
Sorting Algorithms<br>
Sorting algorithms are used to rearrange the elements in an array or a given data structure either in an ascending or descending order. The comparison operator decides the new order of the elements.
<br>Why do we need a sorting algorithm?<br>
<br><b>o</b> An efficient sorting algorithm is required for optimizing the efficiency of other algorithms like binary search algorithm as a binary search algorithm requires an array to be sorted in a particular order, mainly in ascending order.
<br><b>o</b> It produces information in a sorted order, which is a human-readable format.
<br><b>o</b> Searching a particular element in a sorted list is faster than the unsorted list.<br>
<br><h3>Array Definition</h3>
<b>o</b> Arrays are defined as the collection of similar type of data items stored at contiguous memory locations.<br>
<b>o</b> Arrays are the derived data type in C programming language which can store the primitive type of data such as int, char, double, float, etc.<br>
<b>o</b> Array is the simplest data structure where each data element can be randomly accessed by using its index number.<br>
<b>o</b> For example, if we want to store the marks of a student in 6 subjects, then we don't need to define different variable for the marks in different subject. instead of that, we can define an array which can store the marks in each subject at a the contiguous memory locations.
<br>The array marks[10] defines the marks of the student in 10 different subjects where each subject marks are located at a particular subscript in the array i.e. marks[0] denotes the marks in first subject, marks[1] denotes the marks in 2nd subject and so on.
<br>
<br><h3>Memory Allocation of the array</h3>
As we have mentioned, all the data elements of an array are stored at contiguous locations in the main memory. The name of the array represents the base address or the address of first element in the main memory. Each element of the array is represented by a proper indexing.
<br>The indexing of the array can be defined in three ways.<br>
1.	0 (zero - based indexing) : The first element of the array will be arr[0].<br>
2.	1 (one - based indexing) : The first element of the array will be arr[1].<br>
3.	n (n - based indexing) : The first element of the array can reside at any random index number.<br>


<br><h3>Circular Singly Linked List</h3>
<br>In a circular Singly linked list, the last node of the list contains a pointer to the first node of the list. We can have circular singly linked list as well as circular doubly linked list.
We traverse a circular singly linked list until we reach the same node where we started. The circular singly liked list has no beginning and no ending. There is no null value present in the next part of any of the nodes.
<br>

<br><h3>Linked List</h3>
<b>o</b> Linked List can be defined as collection of objects called nodes that are randomly stored in the memory.<br>
<b>o</b> A node contains two fields i.e. data stored at that particular address and the pointer which contains the address of the next node in the memory.<br>
<b>o</b> The last node of the list contains pointer to the null.<br>

<br><h3>Singly linked list</h4> <br>
Singly linked list can be defined as the collection of ordered set of elements. The number of elements may vary according to need of the program. A node in the singly linked list consist of two parts: data part and link part. Data part of the node stores actual information that is to be represented by the node while the link part of the node stores the address of its immediate successor.
Consider an example where the marks obtained by the student in three subjects are stored in a linked list as shown in the figure.<br>
 
<br><h3>Doubly linked list</h3>
Doubly linked list is a complex type of linked list in which a node contains a pointer to the previous as well as the next node in the sequence. Therefore, in a doubly linked list, a node consists of three parts: node data, pointer to the next node in sequence (next pointer) , pointer to the previous node (previous pointer). A sample node in a doubly linked list is shown in the figure.
 <br>
A doubly linked list containing three nodes having numbers from 1 to 3 in their data part, is shown in the following image.<br>
 
<br><h3>Circular Singly Linked List</h3>
In a circular Singly linked list, the last node of the list contains a pointer to the first node of the list. We can have circular singly linked list as well as circular doubly linked list.
We traverse a circular singly linked list until we reach the same node where we started. The circular singly liked list has no beginning and no ending. There is no null value present in the next part of any of the nodes.
 <br>


<br><h3>What is a Stack?</h3>
A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Stack has one end, whereas the Queue has two ends (front and rear). It contains only one pointer top pointer pointing to the topmost element of the stack. Whenever an element is added in the stack, it is added on the top of the stack, and the element can be deleted only from the stack. In other words, a stack can be defined as a container in which insertion and deletion can be done from the one end known as the top of the stack.
<br>Some key points related to stack<br>
<b>o</b> It is called as stack because it behaves like a real-world stack, piles of books, etc.<br>
<b>o</b> A Stack is an abstract data type with a pre-defined capacity, which means that it can store the elements of a limited size.<br>
<b>o</b> It is a data structure that follows some order to insert and delete the elements, and that order can be LIFO or FILO.<br>
<br><h3>Working of Stack</h3>
Stack works on the LIFO pattern. As we can observe in the below figure there are five memory blocks in the stack; therefore, the size of the stack is 5.<br>
Suppose we want to store the elements in a stack and let's assume that stack is empty. We have taken the stack of size 5 as shown below in which we are pushing the elements one by one until the stack becomes full.
 <br>
Since our stack is full as the size of the stack is 5. In the above cases, we can observe that it goes from the top to the bottom when we were entering the new element in the stack. The stack gets filled up from the bottom to the top.
When we perform the delete operation on the stack, there is only one way for entry and exit as the other end is closed. It follows the LIFO pattern, which means that the value entered first will be removed last. In the above case, the value 5 is entered first, so it will be removed only after the deletion of all the other elements.
<br><br><h3>Standard Stack Operations</h3>
The following are some common operations implemented on the stack:<br>
<b>o</b> push(): When we insert an element in a stack then the operation is known as a push. If the stack is full then the overflow condition occurs.<br>
<br><b>o</b> pop(): When we delete an element from the stack, the operation is known as a pop. If the stack is empty means that no element exists in the stack, this state is known as an underflow state.
<br><b>o</b> isEmpty(): It determines whether the stack is empty or not.<br>
<b>o</b> isFull(): It determines whether the stack is full or not.'<br>
<b>o</b> peek(): It returns the element at the given position.<br>
<b>o</b> count(): It returns the total number of elements available in a stack.<br>
<b>o</b> change(): It changes the element at the given position.<br>
<b>o</b> display(): It prints all the elements available in the stack.<br>
<br><h3>PUSH operation</h3>
The steps involved in the PUSH operation is given below:<br>
<b>o</b> Before inserting an element in a stack, we check whether the stack is full.<br>
<b>o</b> If we try to insert the element in a stack, and the stack is full, then the overflow condition occurs.<br>
<b>o</b> When we initialize a stack, we set the value of top as -1 to check that the stack is empty.<br>
<b>o</b> When the new element is pushed in a stack, first, the value of the top gets incremented, i.e., top=top+1, and the element will be placed at the new position of the top.<br>
<b>o</b> The elements will be inserted until we reach the max size of the stack.<br>
 
<br><h3>POP operation </h3>
The steps involved in the POP operation is given below:<br>
<b>o</b>Before deleting the element from the stack, we check whether the stack is empty.<br>
<b>o</b>If we try to delete the element from the empty stack, then the underflow condition occurs.<br>
<b>o</b>If the stack is not empty, we first access the element which is pointed by the top<br>
<b>o</b>Once the pop operation is performed, the top is decremented by 1, i.e., top=top-1.<br>
 
<br><h3>Applications of Stack</h3>
The following are the applications of the stack:<br>
<b>o</b> Balancing of symbols: Stack is used for balancing a symbol. For example, we have the following program:<br>
1.	int main()  <br>
2.	{  <br>
3.	   cout<<"Hello";  <br>
4.	   cout<<"javaTpoint";  <br>
5.	}  <br>
As we know, each program has an opening and closing braces; when the opening braces come, we push the braces in a stack, and when the closing braces appear, we pop the opening braces from the stack. Therefore, the net value comes out to be zero. If any symbol is left in the stack, it means that some syntax occurs in a program.
<br><b>o</b>String reversal: Stack is also used for reversing a string. For example, we want to reverse a "javaTpoint" string, so we can achieve this with the help of a stack.
<br>First, we push all the characters of the string in a stack until we reach the null character.
<br>After pushing all the characters, we start taking out the character one by one until we reach the bottom of the stack.
<br><b>o</b>UNDO/REDO: It can also be used for performing UNDO/REDO operations. For example, we have an editor in which we write 'a', then 'b', and then 'c'; therefore, the text written in an editor is abc. So, there are three states, a, ab, and abc, which are stored in a stack. There would be two stacks in which one stack shows UNDO state, and the other shows REDO state.
<br>If we want to perform UNDO operation, and want to achieve 'ab' state, then we implement pop operation.
<br><b>o</b>Recursion: The recursion means that the function is calling itself again. To maintain the previous states, the compiler creates a system stack in which all the previous records of the function are maintained.
<br><b>o</b>DFS(Depth First Search): This search is implemented on a Graph, and Graph uses the stack data structure.
<br><b>o</b>Backtracking: Suppose we have to create a path to solve a maze problem. If we are moving in a particular path, and we realize that we come on the wrong way. In order to come at the beginning of the path to create a new path, we have to use the stack data structure.
<br><b>o</b>Expression conversion: Stack can also be used for expression conversion. This is one of the most important applications of stack. The list of the expression conversion is given below:
<br><b>o</b>Infix to prefix<br>
<b>o</b>Infix to postfix<br>
<b>o</b>Prefix to infix<br>
<b>o</b>Prefix to postfix<br>
Postfix to infix<br>

<br><h3>Queue</h3>
1. A queue can be defined as an ordered list which enables insert operations to be performed at one end called REAR and delete operations to be performed at another end called FRONT.
<br>2. Queue is referred to be as First In First Out list.
<br>3. For example, people waiting in line for a rail ticket form a queue.<br>

 

<br><h3>Applications of Queue</h3>
<br>Due to the fact that queue performs actions on first in first out basis which is quite fair for the ordering of actions. There are various applications of queues discussed as below.
<br>1.	Queues are widely used as waiting lists for a single shared resource like printer, disk, CPU.
<br>2.	Queues are used in asynchronous transfer of data (where data is not being transferred at the same rate between two processes) for eg. pipes, file IO, sockets.
<br>3.	Queues are used as buffers in most of the applications like MP3 media player, CD player, etc.
<br>4.	Queue are used to maintain the play list in media players in order to add and remove the songs from the play-list.
<br>5.	Queues are used in operating systems for handling interrupts.
<br><h3>Tree Data Structure</h3>
We read the linear data structures like an array, linked list, stack and queue in which all the elements are arranged in a sequential manner. The different data structures are used for different kinds of data.
Some factors are considered for choosing the data structure:<br>
<br><b>o</b> What type of data needs to be stored?: It might be a possibility that a certain data structure can be the best fit for some kind of data.
<br><b>o</b> Cost of operations: If we want to minimize the cost for the operations for the most frequently performed operations. For example, we have a simple list on which we have to perform the search operation; then, we can create an array in which elements are stored in sorted order to perform the binary search. The binary search works very fast for the simple list as it divides the search space into half.
<br><b>o</b> Memory usage: Sometimes, we want a data structure that utilizes less memory.<br>
A tree is also one of the data structures that represent hierarchical data. Suppose we want to show the employees and their positions in the hierarchical form then it can be represented as shown below:
 <br>
The above tree shows the organization hierarchy of some company. In the above structure, john is the CEO of the company, and John has two direct reports named as Steve and Rohan. Steve has three direct reports named Lee, Bob, Ella where Steve is a manager. Bob has two direct reports named Sal and Emma. Emma has two direct reports named Tom and Raj. Tom has one direct report named Bill. This particular logical structure is known as a Tree. Its structure is similar to the real tree, so it is named a Tree. In this structure, the root is at the top, and its branches are moving in a downward direction. Therefore, we can say that the Tree data structure is an efficient way of storing the data in a hierarchical way.
<br>Let's understand some key points of the Tree data structure.
<br><b>o</b>A tree data structure is defined as a collection of objects or entities known as nodes that are linked together to represent or simulate hierarchy.
<br><b>o</b>A tree data structure is a non-linear data structure because it does not store in a sequential manner. It is a hierarchical structure as elements in a Tree are arranged in multiple levels.
<br><b>o</b>In the Tree data structure, the topmost node is known as a root node. Each node contains some data, and data can be of any type. In the above tree structure, the node contains the name of the employee, so the type of data would be a string.
<br><b>o</b>Each node contains some data and the link or reference of other nodes that can be called children.
<br>Some basic terms used in Tree data structure.<br>
<br><h3>Let's consider the tree structure, which is shown below:</h3>
 
In the above structure, each node is labeled with some number. Each arrow shown in the above figure is known as a link between the two nodes.
<br><b>o</b>Root: The root node is the topmost node in the tree hierarchy. In other words, the root node is the one that doesn't have any parent. In the above structure, node numbered 1 is the root node of the tree. If a node is directly linked to some other node, it would be called a parent-child relationship.
<br><b>o</b>Child node: If the node is a descendant of any node, then the node is known as a child node.
<br><b>o</b>Parent: If the node contains any sub-node, then that node is said to be the parent of that sub-node.
<br><b>o</b>Sibling: The nodes that have the same parent are known as siblings.
<br><b>o</b>Leaf Node:- The node of the tree, which doesn't have any child node, is called a leaf node. A leaf node is the bottom-most node of the tree. There can be any number of leaf nodes present in a general tree. Leaf nodes can also be called external nodes.
<br><b>o</b>Internal nodes: A node has atleast one child node known as an internal
<br><b>o</b>Ancestor node:- An ancestor of a node is any predecessor node on a path from the root to that node. The root node doesn't have any ancestors. In the tree shown in the above image, nodes 1, 2, and 5 are the ancestors of node 10.
<br><b>o</b>Descendant: The immediate successor of the given node is known as a descendant of a node. In the above figure, 10 is the descendant of node 5.
Properties of Tree data structure
<br><b>o</b>Recursive data structure: The tree is also known as a recursive data structure. A tree can be defined as recursively because the distinguished node in a tree data structure is known as a root node. The root node of the tree contains a link to all the roots of its subtrees. The left subtree is shown in the yellow color in the below figure, and the right subtree is shown in the red color. The left subtree can be further split into subtrees shown in three different colors. Recursion means reducing something in a self-similar manner. So, this recursive property of the tree data structure is implemented in various applications.
 
<br><b>o</b>Number of edges: If there are n nodes, then there would n-1 edges. Each arrow in the structure represents the link or path. Each node, except the root node, will have atleast one incoming link known as an edge. There would be one link for the parent-child relationship.
<br><b>o</b>Depth of node x: The depth of node x can be defined as the length of the path from the root to the node x. One edge contributes one-unit length in the path. So, the depth of node x can also be defined as the number of edges between the root node and the node x. The root node has 0 depth.
<br><b>o</b>Height of node x: The height of node x can be defined as the longest path from the node x to the leaf node.<br>
Based on the properties of the Tree data structure, trees are classified into various categories.<br>


</div>
<br><br>
<div class="footer">
	<div class="f-bg-w3l">
		<div class="container">
			<div class="col-md-4 w3layouts_footer_grid">
				<h2>Follow <span>Us</span></h2>
				<ul class="social_agileinfo">
					<li><a href="#" class="w3_facebook"><i class="fa fa-facebook"></i></a></li>
					<li><a href="#" class="w3_twitter"><i class="fa fa-twitter"></i></a></li>
					<li><a href="#" class="w3_instagram"><i class="fa fa-instagram"></i></a></li>
					<li><a href="#" class="w3_google"><i class="fa fa-google-plus"></i></a></li>
				</ul>
			</div>
			<div class="col-md-8 w3layouts_footer_grid">
				
				<ul class="w3l_footer_nav">
					
					<li><a href="/python">Python</a></li>
					<li><a href="/java">Java </a></li>
					<li><a href="/data-structure">Data Structures</a></li>
				</ul>
				<p>Â©2021 Code Masters All Rights Reserved.</a></p>
			</div>
			<div class="clearfix"> </div>
		</div>
	</div>
</div>

</body>
</html>