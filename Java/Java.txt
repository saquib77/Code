23 Jan/2021

Operator : Predefined token's & keywords that can perform some kind of operations on operands

Categories : It having 2 types :-
		1) No operands invloved.
		2) Types of operations.

			1.i) Unary(-x,++x,--x,(Negation) Operator)
			  ii) Binary (x-y,x+y,x&&y,x||y)
			  iii) Ternary (condition ? exp1 : exp2)

			2 i) Arithematic Operator(-, +, % , /, *) Not applicable with float & double.
			  ii) Relational Operator (==,>=,=<,!=)
			  iii) Logical Operator(!,&&,||)
		3) Bitwise Operator(&,|,^,<<,>>,>>>)
			i) & Op -> 
						byte x=10;
						byte y=8;
						
						byte z=x&y;		0 0 0 0 1 0 1 0   (10)
										0 0 0 0 1 0 0 0   (8)  &
										---------------
										0 0 0 0 1 0 0 0   (8)
			ii) | Op ->
										0 0 0 0 1 0 1 0   (10)
										0 0 0 0 1 0 0 0   (8)  |
										---------------
										0 0 0 0 1 0 1 0   (8)

			iii) << Left Shift (Multiplication)
			iv)  >> Right Shift (Division)
			 v)  >>> Right Shift With Carry.

		* Usage of Bitwise :
			i) Determining Even or Odd
				1 -> (x%2==0) EVEN OR (x%2==1) ODD
				2 -> (x&1)==0 EVEN OR (x&1)==1 ODD
			ii) Off first 1 bit from left
				suppose x=10;
					x=x & (x-1)
			iii) Counting num of One's
					byte x=10;
						int count=0;
						while(x>0){
							if((x&1)==1) count++;
							x=x>>1;
						}
						System.out.println(count);

						int count=0;
						while(x>0){
							count++;
							x=(x&(x-1));
						}
						System.out.println(count);
			iv) Toggle a particular bit
						x=x^(1<<(pos-1));

			v) ON/OFF a Particular bit
						i)  ON -> x|(1<<(pos-1));
						ii) OFF ->  y=x^(1<<(pos-1));
									x=x&y;
			vi) Power of 4
				int x=65;
	            int c=0,p=0;
	            while(x!=0){
	                    if((x&1)==1) c++;
	                    p++;
	                    x=x>>1;
	            }
	            if(c==1 && (p&1)==1) System.out.println("Power of Four");
	            else System.out.println("Not a power of four");

Control Statement : Statement that control the flow of execution of process
					there are 3 types of Control statement
						i) Conditional      - if ,if-else,Switch
						ii)Loop Based		- for loop,while loop,do-while loop,for-each loop
						iii) Jump statement - break,continue,return
					In Java goto is not a conditional statement but it is a reserved word.

					Two Types of Loop : i) Deterministic & ii) Non-Deterministic.

					Jump Statement in Java 
						i) Labeled Break 
							ab:
							for(-----------){
								for(--------){
									if(----) break ab;
								}
							}

						ii) Labeled Continue
							ab:
							for(-----------){
								for(--------){
									if(----) continue ab;
								}
							}

					Conditional Statement : 
						i)Switch:

							switch(x){
								case 1:
									-------
								case 'A':
									-------
								case "String":    //<-----Not in C/C++
									-------
							}
						ii) for-each:


Java Code Convention:
	i) Keyword : Keyword are in lower case
	ii) Variables & Method : First character of each word should be in upper case except first word.
					int ageOfStudent;
					int maxNum;

					int getNum();//for method

	iii) Constant :	Each character should be in upper case.
					final int AGE=20;

	iv) Class : First character of each word should be in upper case
					class MyClass{
						--------
						------
						---
					}	

	v) int identifier can use currency symbol in java.

	#* A Source file can have more than one class but it can have only one public class

	if class having public class MClass{ } source file name be also same as class name.

	#java Class File -> Class Loader -> Method Area ->  Heap Memory (String Const Pool) -> Stack -> PC(Program Counter) 


	#* Static  & Non-Static Block:
		class StaticDemo{
			public static void main(String[]args){   //from JDK 5.1 main is necessary. if we dont write main method its a runtime error.
				System.out.println("Main Block");
			}
			static{
				System.out.println("Static Block");
			}
		}

		O/P: Static Block
			 Main Block

		class StaticMain{
			public static void main(String[]args){
				System.out.println("Main Block");
				StaticDemo sd=new StaticDemo();
			}
		}
		class StaticDemo{
			static{
				System.out.println("Static Block");
			}
		}

		O/P: Main Block
			 Static Block

###Static Demo
	class StaticMain{
        public static void main(String[]args){
                System.out.println("Main Block");
                StaticDemo sd=StaticDemo.factory();
                sd.printer();
        }

	}
	class StaticDemo{
        private StaticDemo(){}                         //made private not to access by anyone. also we can achive singleton pattern
        private static StaticDemo sd;				   //also we are able to make only one object at a time. 
        static{
                sd=new StaticDemo();
        }
        static StaticDemo factory(){
                return sd;								// returning object.
        }
        void printer(){
                System.out.println("Printer");
        }
	}

	O/P: Main Block
		 Printer.


###Non-Static Demo

	class NonStaticDemo{
		NonStaticDemo(){
				System.out.println("Constructor Called");          // constructor is called after nonstatic block call.	
		}
        {
                System.out.println("Non-Static Block");            // How many time the object is created Non-Static block will call that many time the object is created.
        }
        static {
                System.out.println("Static Block");               // And Static member will call one time when object is created. 
        }
	}

	class NonStaticMain{
        public static void main(String[]args){
                NonStaticDemo nsd1=new NonStaticDemo();
                NonStaticDemo nsd2=new NonStaticDemo();
        }
	}

	O/P: Static Block
		 Non-Static Block
         Constructor Called
         Non-Static Block
         Constructor Called


    Member of a class
    	i) Variables.
    	ii) Constants
    	iii) Constructor
    	iv) Methods
    	v) Classes(Nested Class).


    Automatic Garbage Collection
    	* Java Has No Desructor Concept as C++ has.
    	* Releasing of memory is done by JVM using mark and sweep technique.
    												| Mark and sweep , If any object of reference is not pointing to anywhere,
    																   JVM will mark those reference of Object and after then when
    												                   JVM is ideal then it will sweep those references. 

 		

 ###Modifiers
 			i) Access Modifier(Modify Accessibilty) : 
 			  *Modifies accessbility of class,interface or its members.
 			  *only public and default accessibility are applicable with class or interface.
 				i)Default(No-Keyword)
 				ii)Private(private)         //Not Applicable in Class
 				iii)Public(public)
 				iv) Protected(protected)    //Not Applicable in Class

 			ii) Non-Access Modifier(Modify behaviour)            //// Non-Access Modifiers cannot applicable with constructor.
 				i) static 
 				ii) final
 				iii) abstract
 				iv) strictfp			(only for method)	Standard : IEEE754
 				v) native
 				vi) transient
 				vii) volatile
 				viii) Synchronised


 		Any Object having Three properties:
 			i) State.(eg; Member's)
 			ii) Identity. (eg; )
 			iii) Behaviour. (What an object can do)



 ###Package Concept:
 			package mypkg;
			import java.util.*;
			class MyClass{
        		public static void main(String[]args){
                	ArrayList ai=new ArrayList();
                	ai.add(30);
 					System.out.println(ai.get(0));
        		}
			}
			To Compile : javac -d . MyCLass.java 
			To Run: java mypkg.MyClass

		package mypkg;
		class AccessDemo{
        	int x=10;
        	public int y=20;
        	protected int z=30;
        	private int k=40;
        	public static void main(String[]args){
            	    AccessDemo a=new AccessDemo();
                	System.out.println(a.x+" "+a.y+" "+a.z+" "+a.k);
        	}
		}
		To Compile : javac -d . AccessDemo.java
		To Run : java mypkg.AccessDemo



		package mypkg;
		class AccessDemo{
        	int x=10;
        	public int y=20;
        	protected int z=30;
        	private int k=40;
        	public static void main(String[]args){
            	    AccessDemo a=new AccessDemo();
                	System.out.println(a.x+" "+a.y+" "+a.z+" "+a.k);
        	}
		}

		package mypkg;
		class AccessDemo1{
        	public static void main(String[]args){
            	    AccessDemo a=new AccessDemo();
                	System.out.println(a.x+" "+a.y+" "+a.z+" "+a.k);   //Error : Private Member cannot be accessible in another class of same package.
        	}
		}

		package mpkg;
		class AccessDemo2{
        	public static void main(String[]args){
            	    AccessDemo a=new AccessDemo();
                	System.out.println(a.x+" "+a.y+" "+a.z+" "+a.k);   //Error : Protected ,Default & Private member's cannot call  a.x , a.z , a.k.
        	}
		}

		package mpkg;
		import mypkg.AccessDemo;
		class AccessDemo2 extends AccessDemo{
        	public static void main(String[]args){
                AccessDemo2 a=new AccessDemo2();
                System.out.println(a.y+" "+a.z);
        	}
		}


		# If Class is Default it is not accessible outside the package
		# Also Default Member's Can't accessible out side the package
		# if we inherit another class then only Public & Protected is Accessible out side the class.


		# If we want any package to import then we have to specify the Package/Class path (eg: import.abc.*;  || import.abc.bbc.*;).



		    				PRIVATE 		PROTECTED           DEFAULT             PUBLIC
		
SAME CLASS                    can             can                 can                 can


			SAME PACKAGE      not             can                 can                 can
DIFFRENT
CLASS       When Class is     not             not                 not                 not
              Default

            When Class is     not             Can(Using Child     not                 can
              Public								Class)

#In Java Casting is of 2 Types:
	i) Implcit Casting.
	ii) Explicit Casting.


###Wrapper Class :- (java.lang) package
	To Convert primitive data type into non primitive datatype

		primitive       Size           Non-primitive

	1) byte 			 1              Byte
	2) short			 2				Short
	3) int               4              Integer
	4) long              8              Long
	5) char              2              Character
	6) float             4              Float
	7) double            8              Double
	8) boolean                          Boolean
	(undefined)
		true             8             
		flase            10


###Overloading : (Ease of Code)
	i) Methods & Constructor can overload Within class and in parent-child pair.
	ii) If Methods or constructor coexists with some name & diff signature.
	iii) Early Binding(Polymorpism) At Compile time.
	iv) Late Binding .
	v) Operator Overloading is done to only one operator( + ). But Programmer Point of View(You Can't Overload any operator).
	
	**Signature is Defined by:
		1) Number of Arguments.
		2) Types of Arguments.
		3) Order of Arguments.



**Constructor : It having same name as Class Name, Also it does'nt have return type, It is used to initialize the newly created object or method's.

		class OverloadingDemo{
        	int x,y,z;
        	OverloadingDemo(){} 
        	OverloadingDemo(int a){
        	        x=a;
        	}
        	OverloadingDemo(int a,int b){
                this(a);
                y=b;
        	}
        	OverloadingDemo(int a,int b,int c){
                this(a,b);
                z=c;
        	}
		}
		class OverloadingMain{  
        	public static void main(String[]args){
                OverloadingDemo ob=new OverloadingDemo(1,2);
            	System.out.println(ob.x+" "+ob.y+" "+ob.z);
        	}
		}


	System.out.println("Lucknow");

	System -> java.lang (A Class Name)
	out -> java.io.PrintStream(Reference of Print Stream)
	println() -> Method in PrintStream Class.


###Overridding :  To Enhance the Existing Feature. 

##Factory Method & Sigleton Pattern.

	
	*Factory Method
	class MyClass{
        private MyClass(){}
        void printer(){
                System.out.println("Hello");
        }
        public static MyClass factory(){
                MyClass m=new MyClass();
                return m;
        }
	}

	class FactoryMain{
        public static void main(String[]args){
                MyClass m1=MyClass.factory();
                m1.printer();
        }
	}


	*Singleton Pattern
	class MyClass{
        int x;
        private MyClass(){}
        void printer(){
                System.out.println("Hello");
        }
        static MyClass m=null;
        synchronized public static MyClass factory(){        ///synchronized is done to make at a time one object is created , and uses thread concept that
                if(m==null) m=new MyClass();				 /// if one thread is acquire a object and after releasing the lock on that process then another 
                return m;									 /// thread is able to acquire that lock .
        }
	}

	class FactoryMain{
        public static void main(String[]args){
                MyClass m1=MyClass.factory();
                m1.printer();
                m1.x=20;
                MyClass m2=MyClass.factory();
                System.out.println(m1.x+" "+m2.x);
        }
	}


###Inheritance : Inheritance there must be atleast 2 classes,
				 one is parent & other is child. if child inherites parent,
				 it means all the accessible member of parent can be called through
				 reference of child class.


				 -----------------
				 | Parent Class  |				class ParentClass{
				 |               |					
				 -----------------				}
		  		       /\						class ChildClass extends ParentClass{
				       .								
				       .
				       .						}
				       .
				 -----------------
				 | Child Class   |
				 |               |
				 -----------------


		class Parent{
        	private void p1(){
                System.out.println("P1");
        	}
        	public void p2(){
             	System.out.println("P2");
        	}
		}

		class Child extends Parent{
        	public void p3(){
                System.out.println("P3");
        	}
		}

		class IMain{ 
		    public static void main(String[]args){
		        Parent p=new Parent();
		        p.p2();
		        Child c=new Child();                //Parent c=new Child();
		        c.p2();
		        c.p3();								//Implicit Casting only parent method able to call
		    }
		}


		####Inheritance With Abstraction:
		class Parent{
        	private void p1(){
                System.out.println("P1");
        	}
        	public void p2(){
                System.out.println("P2");
        	}
		}
		class Child extends Parent{
		    public void p2(){
		        System.out.println("P3");
		    }
		}
		class FactoryMethod{
		    public static Parent Factory(){
		        return (new Child());
		    }
		}
		class IMain{
		    public static void main(String[]args){
		        Parent c=FactoryMethod.Factory();
		        c.p2();
		    }
		}


		class Parent{
        private void p1(){
                System.out.println("P1");
        }
        public void p2(){
                System.out.println("P2");
		        }
		}

		class Child extends Parent{
		        public void p2(){
		                System.out.println("P3");
		        }
		}
		class FactoryMethod{
		        public static Parent Factory(){
		                return (new Parent());
		        }
		}
		class IMain{
		        public static void main(String[]args){
		                Child c=(Child)FactoryMethod.Factory();
		                c.p2();
		        }
		}

		RunTime Error:
		Exception in thread "main" java.lang.ClassCastException: class Parent cannot be cast to class Child (Parent and Child are in unnamed module of loader 'app')


		###Abstract Class : An abstract class having abstract methods.
							An Abstract Class can't intantiated Directly
							if a method is abstract then class should have abstract class.
							if a complete class having absract then java consider's class is incomplete, this is flaw in java 


							abstract class AbstractDemo{
							    void printer(){
							            System.out.println("Printer");
							    }
							}

							class AbstractMain{ 
								public static void main(String[]args){
								    AbstractDemo ab=new AbstractDemo();
								    ab.printer();
								}
							}

							AbstractDemo.java:9: error: AbstractDemo is abstract; cannot be instantiated
							AbstractDemo ab=new AbstractDemo();


						abstract class AbstractDemo{
					        void printer(){
					       	    System.out.println("Printer");
					    	}
					    	abstract void p();
						}
						class Achild extends AbstractDemo{
							void p(){
							    System.out.println("P Method");
							}
						}
						class AbstractMain{ 
							public static void main(String[]args){
							    Achild ab=new Achild();
							    ab.printer();
							    ab.p();
							}
						}


				####Child Constructor firstly call ParentClass of Default Constructor  
				if Constructor is parameterized then it is called using super keyword and also it should be a first line of child constructor. 
				* this and super is Non-Static.

				import java.io.*;
				class Parent{
				        PrintStream s=new PrintStream(System.out);
				        int a;
				        Parent(int x){
				                a=x;
				                s.println("No Args Constructor Of Parent");
				        }
				}
				class Child extends Parent{
				        Child(){
				                super(5);
				                s.println("No Args Constructor of CHild");
				        }
				}
				class Imain{
				        public static void main(String[]args){
				                Child c=new Child();
				        }
				}



				###Usage of Super & This Keyword's

					import java.io.*;
					class Parent{
					        PrintStream s=new PrintStream(System.out);
					        void printer(){
					                s.println("Parent");
					        }
					        void caller(){
					                this.printer();
					        }
					}
					class Child extends Parent{
					        void print(){
					                super.caller();
					        }
					}
					class Imain{
					        public static void main(String[]args){
					                Child c=new Child();
					                c.caller();
					                c.print();

					        }
					}




	###INTERFACE

		i) An Entity like class

		Iterface can be public & Default, But can't be private and Protected.

		ii) Being Used
				1) To Provide interface of library
				2) To Provide Maximum Abstraction
				3) As an Agreement between Programmer's  Code & lib.

		iii) Defined Used Interface Keyword

		iv) Can't be intantiated.

		v) There are only 3 types of member's in an interface (Up to JDK7) 
				1) Constants
				2) Abstract Method
				3) Classes

		interface MyInterface{
        	int x=10;            //By Default data member's are public static final
        	void printer();		 // BY Default Member Function are public abstract.
		}

		class InterfaceDemo implements MyInterface,MInterface {    // A class can also implements multiple interface.
		    public void printer(){								//also have to call the member function as accesiblity
		            System.out.println("Printer"+" "+x);
		    }
		}
		class InterfaceMain{  
		    public static void main(String[]args){
		            InterfaceDemo id = new InterfaceDemo();         //MyInterface id = new InterfaceDemo();   --->  it that case only that can be called which having 
 		            id.printer();								   //													realtion to interface and class.
		     		System.out.println(id.x+" "+MyInterface.x);   //Can also be called using object as well as Interface       
		    }
		}


		class ObjectDemo{ 							//Default any class which has not inherited any class then  by default it inherit's the Object Class(java.lang.Object).
		        public String toString(){
		                return "ObjectDemo";
		        }
		}
		class ObjectMain{ 
		        public static void main(String[]args){
		                ObjectDemo od=new ObjectDemo();
		                System.out.println(od.toString());
		                System.out.println(od.hashCode());
		        }
		}



		#In Sense if Data Members.   In Case of Variable , Data Member's are called from parent class, and in case of method it will call from child.
		class Parent{
	        int x;
	        int y;
	        Parent(int a,int b){
                x=a;
                y=b;
	        }
		}
		class Child extends Parent{
	        int x;                   -----> Variable's Hiding
	        int z;
	        Child(int a,int b,int c,int d){
                super(a,b);
                x=super.x;
                y=d;
	        }
		}
		class VariableDemo{
		        public static void main(String[]args){
		                Child c=new Child(10,20,30,40);
		                System.out.println(c.x+" "+c.y+" "+c.z);
		        }
		}


		#### MAX Abstraction :

			interface APIinterface{
        		void printer();
			}
			class API implements APIinterface{
			        public void printer(){
			                System.out.println("Printer of API");
			        }
			}
			class Factory{
			        public static APIinterface factory(){
			                return new API();
			        }
			}

			class EAPI extends API{
			        public void printer(){
			                System.out.println("Printer of EAPI");
			        }
			}

			class APIMain{
			        public static void main(String[]args){
			                APIinterface ap = Factory.factory();
			                ap.printer();     
			        }
			}


			### Interface as an Agreement

				interface APIinterface{
				        void printer();
				}
				class API{
				        void M(APIinterface ia){
				                ia.printer();               
				        }
				}
				class Factory{
				        public static API factory(){
				                return new API();
				        }
				}

				class MyClass implements APIinterface{
				        public void printer(){
				                System.out.println("Printer of MyClass");
				        }
				}

				class APIMain{
				        public static void main(String[]args){
				                API ap = Factory.factory();
				                ap.M(new MyClass());
				        }
				}


### Tagging Interface/Marker Interface : Blank Interface ,used to make an agreement , 
						if it implements the Serializable then only it is able to serialize.

	##Adapter Class : 



	##Inner Class : 
			if a class is a member of another class that class is called inner class.(Class within Class)

			Inner class of 4 types : 
				i)		Non-Static Inner Class(Inner Class)
				ii)		Static Inner Class (Nested Class)
				iii)	Method - Local Inner Class
				iv)		Annoymous Inner Class.

		i) Non Static Inner Class.
			class Outer{
				int x;
				Outer(int a){
					x=a;
				}
				class Inner{
					void Printer(){
						System.out.println(x);
					}
				}
			}
			class NestedMain{
				public static void main(String[]args){
					Outer.Inner oi = new Outer(5).Inner();
					oi.Printer();
				}
			}
		
		ii) Static Inner Class .

			class Outer{
	        	int x;
	        	Outer(int a){
	                x=a;
	        	}
	        	static class Inner{
	                void Printer(){
	                        Outer o=new Outer(5);
	                        System.out.println(o.x);
	                }
	        	}
			}
			class NestedMain{
		        public static void main(String[]args){
		                Outer.Inner oi = new Outer.Inner();
		                oi.Printer();
		        }
			}

		iii) Method Local Inner Class.

				class Outer{
					void p(){
						class Inner{
							void p2(){
								System.out.println("P2 Method");
							}
						}
						Inner i=new Inner();
						i.p2();
					}
				}
				class LocalInner{
					public static void main(String[]args){
						Outer o=new Outer();
						o.p1();
					}
				}


		iv) Annoymous Inner Class.   (its implements a interface || it extends a class)
									  it does'nt have any name. 

				interface A{
					void printer();
				}
				class AnnoymousClass{
					public static void main(String[]args){
						A a=new A(){
							public void printer(){
								System.out.println("Printer Method");
							}
						};
						a.printer();
					}
				}:



				##InterfaceAsAgreement

				//----------------------------//API
				interface MyInterface{
				        void printer();
				}
				class MyClass{
				        void m(MyInterface mi){
				                mi.printer();
				        }
				}
				class Factory{
				        public static MyClass factory(){
				                return new MyClass();
				        }
				}
				//---------------------------//Programmer Code
				class Pcode{
				        public static void main(String[]args){
				                MyClass my=Factory.factory();
				                my.m(new MyInterface(){
				                        public void printer(){
				                                System.out.println("Printer Method");
				                        }
				                });
				        }
				}


	###Final

		* Its a non Access Modifier.
		* It Can be Applied with 
				1) Variable.  ---> Value can't be Changed.
				2) Methods.   ---> Methods can not be Overrided.
				3) Classes    ---> Class can't be extended.


			class Parent{
				public final void p(){
					System.out.println("P Method");
				}
			}
			class Child extends Parent{
				public void p(){
					System.out.println("P of Child");
				}
			}
			class PCmain{
				public static void main(String[]args){
					Child c=new Child();
					c.p();
				}
			}

	-----------------------------------------------------------------------------------

	# POJO (Plain Old Java Object):
			* Object of independent class,mean class must not extends 
			  any class or implements any interface.
			* In worst case it can implement tagging or marker interface.

		*Java Bean:
			* It is an enhancement of POJO.
			* Having Only private variables and getter and setter method to 
			  access and set values in variable.


			  classJBeanDemo{
			  	private int age;
			  	private String name;
			  	public int getAge(){
			  		return this.age;
			  	}
			  	public void setAge(int age){
			  		this.age=age;
			  	}
			  }


		Java Bean is POJO , it contains Private members , also it should be having getter and setter method to set the value and get the value.
		
	##Commad Line Arg :

		class CDM{
        public static void main(String[]args){			//String... args ---->> Elipsis(...)
                for(int i=0;i<args.length;i++){
                        System.out.println(args[i]);
                }
        }

	##Variable-Arity Method :

		class CMD{
		    void printer(float f,int... x){
		            for(int i=0;i<x.length;i++){
		                    System.out.println(x[i]);
		            }
		    }
		}
		class CMDMain{
			public static void main(String[]args){
		    	CMD c=new CMD();
		    	c.printer(3.5f,1,2,3,4,5,6,7);
			}
		}




	####Interface and Class :


		class -----extends----> class  (single)

		class-------implements----->interface (multiple)

		interface-----extends------>interface  (single)


			interface A{
			        void p();
			}
			interface B extends A{
			        void p2();
			}

			class inter implements A,B{
			        public void p(){
			                System.out.println("P Method");
			        }
			        public void p2(){
			                System.out.println("P2 Method");
			        }
			}
			class MyClass2{
			        public static void main(String[]args){
			                B i=new inter();
			                i.p();
			                i.p2();
			        }
			}


	##Boxing & Unboxing AND Auto Boxing & Auto Unboxing :

		Boxing : When explicitly primitive to Non-Primitive.   eg: Integer i=new Integer();

		Unboxing : When explicitly Non-primitive to Primitive.  eg: int x=i.intValue();

		AutoBoxing : When implicitly primitive to Non-Primitive.

		Auto Unboxing : When implicitly Non-primitive to Primitive.



			import java.util.*;
			class arList{
			    public static void main(String[]args){
			            ArrayList a=new ArrayList();
			            a.add(2);
			            a.add("Lucknow");
			            a.add(3.54f);
			            int x=((Integer)a.get(0)).intValue();
			            System.out.println(x);
			            for(int i=0;i<a.size();i++){
			                    System.out.println(a.get(i));
			            }
			    }
			}



		##Scanner Class : 

				import java.util.Scanner;
				class Scan{
				        public static void main(String[]args){
				                Scanner sc=new Scanner(System.in);
				                String in=sc.nextLine();
				                String[]a=in.split(" ");
				                for(int i=0;i<a.length;i++){
				                        int x=Integer.parseInt(a[i]);
				                        System.out.println(x);
				                }
				        }
				}



		###Exception Handling :

			Exception : Undesirable Event that occur at run time. If has not been handled process will terminate.

						It is of 2 types :
								i) Checked Exception(Detected By Compiler)
								ii) Unchecked Exception(Undetected By Compiler)
			
			import java.util.Scanner;
			class ExceptionDemo{
			        public static void main(String[]args){
			                int x=0,y=0;
			                Scanner sc=new Scanner(System.in);
			                System.out.println("Enter 2 Number :");
			                x=sc.nextInt();
			                y=sc.nextInt();
			                int z=x/y;
			                System.out.println(z);
			        }
			}

			import java.util.Scanner;
			class ExceptionDemo1{
			        public static void main(String[]args){
			                int x=0,y=0,z=0;
			                Scanner sc=new Scanner(System.in);
			                System.out.println("Enter 2 Number :");
			                String ip=sc.nextLine();
			                String[]ar=ip.split(" ");
			                x=Integer.parseInt(ar[0]);
			                y=Integer.parseInt(ar[1]);
			                try{
			                        z=x/y;
			                        System.out.println(z);
			                }catch(ArithmeticException ae){
			                        System.out.println("Second Value Could not be zero :");
			                        y=sc.nextInt();
			                        z=x/y;
			                }
			                System.out.println(z);
			        }
			}


			Unchecked Exception : 

				class UnCheckedException{
			        public static void main(String[]args){
		                int[] ar=new int[5];
		                for(int i=0;i<10;i++){
		                        ar[i]=i+5;
		                }
		                for(int i=0;i<ar.length;i++){
		                        System.out.println(ar[i]);
		                }
			        }
				}


			Checked Exception :

				import java.io.*;
				class CheckedException{
				    public static void main(String[]args){
				            File f=new File("/home/Code/Java/Java.txt");
				            FileInputStream fis=new FileInputStream(f);            ///Need to be handled.
				            int data;
				            while((data=fis.read())!=-1){
				                    System.out.println((char)data);
				            }
				    }
				}



				import java.io.*;
				class CheckedException{
				        public static void main(String[]args){
				                File f=new File("/home/saquib/Code/Java/Java.txt");
				                try{
				                        FileInputStream fis=new FileInputStream(f);
				                        int data;
				                        while((data=fis.read())!=-1){
				                                System.out.print((char)data);
				                        }
				                }catch(Throwable t){
				                        System.out.println("File Not Foune || IO Error!");
				                }
				        }
				}



				Exception Handling Keyword:
					i) try
					ii) catch
					iii) finally
					iv) throw
					v) throws


				tyr{
					-----E1
					-----E2
					-----E3
				}catch(E3 e3){
					-----
					-----
					-----
				}catch(E2 e2){
					-----
					-----
					-----
				}catch(E1 e1){
					-----
					-----
					-----
				}finally{					//finally ( it will always execute ) .
					------
					------
					------
				}


				E3 	    |		E1 --->
				E2 	    |		E2 --->  Wrong , Because E1 is the parent of E2 , though E3.
				E1 	    |		E3 --->




				##Try with Resource :

						We use try with resource to not to use finally.

						try(Connection con = DriverManager.getConnection(url,userName,password)){

						}catch(----){				// After the try block connection will Automatically closed.

						}


				##Throw && Throws : 

					Throw : to throw the object of some exception occured.

					Throws : to get the info to the compiler that it can throws the method. 

					class A{
						void m() throws E{
							----
							----
							----
							if(---){
								throw new E();
							}
						}
					}

					class B{
						void m1(){
							A a=new A();
							try{
								a.m();
							}catch(E e){
								-----
								-----
							}
						}
					}



				##Exception Chainning || Exception Propagation : 

						class A{
							void m() throws E{
								throw new E();
							}
						}
						class B{
							void m1() throws E{
								A a=new A();
								a.m();
							}
						}
						class main{
							public static void main(String[]args) throws E{
								B b=new B();
								try{
									b.m1();
								}catch(E e){
									----
									----
									----
								}
							}
						}


			## Array in java : 

					In Java array is an object that can store multiple homogenous(same data types) data in consecutive memory loaction. 
					It is an idex based system, idex starting from 0

					int[] a = new int[5];
					int a[]=new int[5];

					int[] b={2,3,4,5};
					
					int [] c = new int[]{2,3,4,5}; ------>Annonymous Array.
					
					MyClass[] m = new MyClass[5]; 

					Two D array is of two type : 
						i) Row Major.
						ii) Column Major.


					import java.util.Scanner;
					class Arr{
					        public static void main(String[]args){
					                Scanner sc=new Scanner(System.in);
					                int []a=new int [5];
					                for(int i=0;i<a.length;i++){
					                        a[i]=sc.nextInt();
					                }
					                for(int i=0;i<a.length;i++){
					                        System.out.println(a[i]);
					                }
					        }
					}


					class twoDarr{
					        public static void main(String[]args){
					                int [][]td={{1,2,3,4},{4,5},{6,7,8},{9,10,11,12,13,14}};
					                for(int i=0;i<td.length;i++){
					                        for(int j=0;j<td[i].length;j++){
					                                System.out.print(td[i][j]+" ");
					                        }
					                        System.out.println();
					                }
					        }
					}


					class twoDarr{
					        public static void main(String[]args){
					                int [][]td=new int[4][];//{{1,2,3,4},{4,5},{6,7,8},{9,10,11,12,13,14}};    ///NullPointerException.
					                for(int i=0;i<td.length;i++){
					                        td[i]=new int[]{2,3,4};						// Run time value assigning.
					                        for(int j=0;j<td[i].length;j++){
					                                System.out.print(td[i][j]+" ");
					                        }
					                        System.out.println();
					                }
					        }
					}

					class twoDarr{
					        public static void main(String[]args){
					                int [][]td={{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};
					                for(int i=0;i<td[0].length;i++){
					                        for(int j=0;j<td.length;j++){
					                                System.out.print(td[j][i]+" ");
					                        }
					                        System.out.println();
					                }
					        }
					}

					When we are fetching the column wise the it will load the refference of that particular block, and these may lead to miss the data of that column.


			###In Java all the passing object is based on reference.

			##String in Java : (java.lang.String;)

				*In Java ,String is a class ,object of which can store the sqquence of the characters in consecutive memory locations.
				*characters can be retrived or accessed using index
				*index  starting from 0
				*instance of string can be created in 2 ways:

						1 ) String s = "Lucknow";           ///It will create in string constant pool into heap of jvm ,and also if same string of another object then it
															//will not create another object it will return same ref of previous string object.

						2 ) String s= new String("kanpur");  // It will create into heap .

				* instance of string in java is immutable .

				Methods in String :

					i)      boolean equals  	---> x.equals(y);
					ii)     int length  		---> x.length();
					iii)    String concat  		---> s=s1.concat(s2);
					iv)		String charAt  		---> c=charAt(i);
					v)		int indexOf			---> n=indexOf(c);
					vi)		int lastIndexOf 	---> lastIndexOf(c);
					vii)	String toUpperCase 	---> toUpperCase();
					viii)	String toLowerCase 	---> toLowerCase();
					ix)		String trim 		---> s.trim();
					x)		String substring  	---> s.substring(startIdx,offset);		//offset idx of that char + 1.
					xi)		String substring 	---> s.substring(startIdx);				//startIdx to last.
					xii)	char[] toCharArray()---> s.toCharArray();				//String ss=new String(char[]ch);
					xiii)   String[] Split(s)	---> s.split(" ");

				###*** Operator Overloading is not provided to programmer , but the language developer have done only one place in String Class, 
						where '+' is overloaded, to concatenate the two string .


					Muable String in Java :

						* Can be created using either StringBuffer
							or StringBuilder.

						* Diff Between StringBuffer & StringBuilder.
										|						|
										methods of  			methods of
										StringBuffer are 		StringBuilder
										Synchronised.			Asynchronised.

						* In StringBuffer it Syncronised the methods and after the lock is released , then also another method can use the lock.


						StringBuffer sb = new StringBuffer();

						StringBuffer sb = new StringBuffer("Lucknow");

						StringBuffer sb = new StringBuffer(10);

						Initially StringBuffer capacity() method is 16 .

						Initially StringBuffer length() method is 0.



						class strBuff{
					        public static void main(String[]args){
					            StringBuffer sb=new StringBuffer();
					            StringBuffer sb1=new StringBuffer("Lucknow");
					            StringBuffer sb2=new StringBuffer(10);

					            System.out.println(sb.capacity());			16
					            System.out.println(sb.length());			0
					            System.out.println(sb1.capacity());			7+16 - 23
					            System.out.println(sb1.length());			7
					            System.out.println(sb2.capacity());			10
					            System.out.println(sb2.length());			0
					        }
						}



						* In StringBuffer 
								* the initial capacity of StringBuffer is Exceded then , JVM will 
								* search the memory of the length (currentCapacity+1)*2.
								* and then acquire & lock that memory.
								* Copy the character of current object into new acquired memory.
								* update ref table with the new address of StringBuffer Object.




						###Methods of StringBuffer	& StringBuilder.

							1) int length()												->length of string.
							2) int capacity()											->capacity of StringBuilder.
							3) void ensureCapacity()									->to ensure the length of memory of StringBuilder.
							4) StringBuilder reverse()									->reverse the string.
							5) int indexOf(String s)									->find the char at index of.
							6) int lastIndex(String s)									->find the last index of the char.
							7) char charAt(int index)									->find the char at particular index.
							8) String substring(int sidx,int offset)					->find the substring of string , start index to upto_index.
							9) String substring(int sidx)								->find the substring from start index.
							10) StringBuilder delete(int sidx,int offset)				->to delete the char or str in range from start to end
							11) StringBuilder insert(int sidx,String str)				->to insert the string or char in range.
							12	StringBuilder repalce(int sidx,int offset,String str)  	->replace the string to another in range.



						###Multithreading :
							Thread : Execution of a process.

							Context Switching : When an Current Process is maintained and then new process is loaded,after new process is being excuted,
												then maintained previous process is being loaded into processor.


							Using Runnable Interface : 
								public class ThreadDemo implements Runnable{
									public void run(){
										for(int i=0;i<5000;i++){
											System.out.println(i);
										}
									}
								}
								class ThreadMain{
									public static void main(String[]args){
										Runnable r = new ThreadDemo();
										Thread t1 = new Thread(r);
										Thread t2 = new Thread(r);
										t1.start();
										t2.start();
									}
								}


							Using Annoymous Class : 
								public class ThreadDemo implements Runnable{
								        public void run(){
								                for(int i=0;i<5000;i++){
								                        System.out.println(i);
								                }
								        }
								}
								class ThreadMain{
								        public static void main(String[]args){
								                //Runnable r = new ThreadDemo();
								                //Thread t1 = new Thread(r);
								                Thread t1 = new Thread(new ThreadDemo(){
								                        public void run(){
								                                for(int i=0;i<500;i++){
								                                        System.out.println(i);
								                                }
								                        }
								                });
								                //Thread t2 = new Thread(r);
								                Thread t2 = new Thread(new ThreadDemo(){ 
								                        public void run(){
								                                for(int i=0;i<500;i++){
								                                        System.out.println(i);
								                                }
								                        }
								                });
								                t1.start();
								                t2.start();
								        }
								}



							Using Thread Class :

									public class ThreadDemo1 extends Thread{
									        public void run(){
									                for(int i=0;i<5000;i++){
									                        System.out.println(i);
									                }
									        }
									}
									class ThreadMain{
									        public static void main(String[]args){
									                Thread t1 = new ThreadDemo1();
									                Thread t2 = new ThreadDemo1();
									                t1.start();
									                t2.start();
									        }
									}

						### Life Cycle of a thread :


											--<---Blocked.
											|		|
								New -> Runnable -> Running -> End/Dead/Terminated
											|		|
											--<---IO Wait.





					###JDBC(Java Database Connectivity)

					 [	Java File ] <---> [ JAVA Client API | JAVA Server API ] <---> [ mysqld ]


					Step 1 : Add Server API in build path of the project.

					Step 2 : To Use client API in Project import java.sql.*;

					Step 3 : Register Server API with client API

								try {
									Class.forName("com.mysql.jdbc.Driver");
									String url="jdbc:mysql://localhost:3306/test"
									String uname="root";
									String pass="Saquib@77";
								}catch(ClassNotFoundException cnf){
									cnf.printStackTrace();
								}
							
					Step 4 : Create 3 String Corresponding database url,uname & pass.

					Step 5 : Establish Connection with DB Server.

							Connection con = DriverManager.getConnection(url,uname,pass);


						try {
							Class.forName("com.mysql.cj.jdbc.Driver");
							String url="jdbc:mysql://localhost:3306/test";
							String uname="root";
							String pass="Saquib@77";
							Connection con = DriverManager.getConnection(url, uname, pass);
							Statement st = con.createStatement();
							String qry = "create table jdbc_demo(id int(10) primary key,name char(20))";
							st.execute(qry);
						}catch(ClassNotFoundException cnf){
							cnf.printStackTrace();
						}catch(SQLException cnf) {
							cnf.printStackTrace();
						}


					Step 6: get ref of statement 
								Statement st = con.createStatement();

					Step 8 : Write a query
								String qry = "create table jdbc_demo(id int(10) primary key,name char(20))";

					Steo 9 : fire query
								st.execute(qry);





				### Getting Data from Mysql using JDBC

						package MyPkg;
						import java.sql.*;
						public class DbDemo {

							public static void main(String[] args) {
								try {
									Class.forName("com.mysql.cj.jdbc.Driver");
									String url="jdbc:mysql://localhost:3306/test";
									String uname="root";
									String pass="Saquib@77";
									Connection con = DriverManager.getConnection(url, uname, pass);
									Statement st = con.createStatement();
									String qry = "select id,name from jdbc_demo";
									ResultSet rs = st.executeQuery(qry);
									while(rs.next()) {
										System.out.println(rs.getInt(1)+" "+rs.getString(2));
									}
								}catch(ClassNotFoundException cnf){
									cnf.printStackTrace();
								}catch(SQLException cnf) {
									cnf.printStackTrace();
								}
								
							}

						}


					##DbDemo.java

						package MyPkg;
						import java.sql.*;
						public class DbDemo {

							public static void main(String[] args) {
								try {
									Class.forName("com.mysql.cj.jdbc.Driver");
									String url="jdbc:mysql://localhost:3306/test";
									String uname="root";
									String pass="Saquib@77";
									DbBean db=new DbBean();
									Statement st = db.createConnection(url,uname,pass);
									String qry= "select id,name from jdbc_demo";
									ResultSet rs = db.selectData(st,qry);
									while(rs.next()) {
										System.out.println(rs.getString(1)+" "+rs.getString(2));
									}
								}catch(ClassNotFoundException cnf){
									cnf.printStackTrace();
								}catch(SQLException cnf) {
									cnf.printStackTrace();
								}
								
							}
						}



					##DbBean.java 

						package MyPkg;
						import java.sql.*;
						public class DbBean {
							
							public Statement createConnection(String url, String uname, String pass ) throws ClassNotFoundException,SQLException {
								Class.forName("com.mysql.cj.jdbc.Driver");
								Connection con = DriverManager.getConnection(url, uname, pass);
								return con.createStatement();
							}
							public boolean insertData(Statement st,String qry) throws SQLException{
								return st.execute(qry);
							}
							public ResultSet selectData(Statement st,String qry) throws SQLException{
								return st.executeQuery(qry);
							}
							
						}



				###Data Access Object : 

					package MyPkg;
					import java.sql.*;
					public class DbDemo {

						public static void main(String[] args) {
							try {
								Class.forName("com.mysql.cj.jdbc.Driver");
								String url="jdbc:mysql://localhost:3306/test";
								String uname="root";
								String pass="Saquib@77";
								DbBean db=new DbBean();
								Statement st = db.createConnection(url,uname,pass);
								String qry= "select id,name from jdbc_demo";
								ResultSet rs = db.selectData(st,qry);
								db.showData(rs);
							}catch(ClassNotFoundException cnf){
								cnf.printStackTrace();
							}catch(SQLException cnf) {
								cnf.printStackTrace();
							}
							
						}
					}


					package MyPkg;
					import java.sql.*;
					public class DbBean {
						
						public Statement createConnection(String url, String uname, String pass ) throws ClassNotFoundException,SQLException {
							Class.forName("com.mysql.cj.jdbc.Driver");
							Connection con = DriverManager.getConnection(url, uname, pass);
							return con.createStatement();
						}
						public boolean insertData(Statement st,String qry) throws SQLException{
							return st.execute(qry);
						}
						public ResultSet selectData(Statement st,String qry) throws SQLException{
							return st.executeQuery(qry);
						}
						public void showData(ResultSet rs) throws SQLException{ 
							int cols=rs.getMetaData().getColumnCount();
							while(rs.next()) {
								for(int i=1;i<=cols;i++) {
									System.out.print(rs.getString(i)+" ");
								}
								System.out.println();
							}
						}
					}




				###Prepared Statement : (It will prevent the SQL Injection).
						It Will Compile the Query of Statement.

					package MyPkg;
					import java.sql.*;
					public class DbDemo {

						public static void main(String[] args) {
							try {
								Class.forName("com.mysql.cj.jdbc.Driver");
								String url="jdbc:mysql://localhost:3306/test";
								String uname="root";
								String pass="Saquib@77";
								Connection con= DriverManager.getConnection(url,uname,pass);
								PreparedStatement pst=con.prepareStatement("select id,name from jdbc_demo where(id=?)");
								pst.setInt(1, 2);
								pst.execute();
								ResultSet rs=pst.getResultSet();
								while(rs.next()) {
									System.out.println(rs.getString("id")+" "+rs.getString("name"));
								}
							}catch(Exception cnf){
								cnf.printStackTrace();
							}
							
						}
					}


					

					##Reflection : 
						* It is a mechanism to analyze compiled class at runtime.
						* Class is a class in java.lang.Class package.
						* 	


						package refPkg;
						class Reflect{
						        void printer(){
						                System.out.println("Printer of Reflect Class");
						        }
						        void display(){
						                System.out.println("Display of Reflect Class");
						        }
						}



						package refPkg;
						class Reflect1{
						        public static void main(String[]args){
						                try{
						                        Class c = Class.forName("refPkg.Reflect");          //Or we can use , Class c = Reflect.class;	
						                        Reflect r = (Reflect)c.newInstance();
						                        r.printer();
						                }catch(Exception e){
						                        e.printStackTrace();
						                }
						        }
						}



						package refPkg;
						class Reflect1{
						        public static void main(String[]args){
						 			Reflect r = new Reflect();
						 			Class ca = r.getClass();
						 			System.out.println(ca.getName());              
						        }
						}	

					--------------------------------------------------------------------------
						package refPkg;
						class ReflectDemo{
						        public int a=0;
						        public int b=1;
						        public int c=3;
						        public ReflectDemo(){}
						        public ReflectDemo(int a){}
						        public void display(){}
						        public void printer(){}
						}

						package refPkg;
						import java.lang.reflect.*;
						class ReflectDemo1{
						        public static void main(String[]args){
						                ReflectDemo r = new ReflectDemo();
						                Class cl=r.getClass();   
						                Constructor[] car = cl.getDeclaredConstructors();
						                Field[] fi = cl.getDeclaredFields();
						                Method[] ma= cl.getDeclaredMethods();
						                for(int i=0;i<car.length;i++){
						                        System.out.println(car[i].getName());
						                }
						                for(int i=0;i<fi.length;i++){
						                        System.out.println(fi[i].getName());
						                }
						                for(int i=0;i<ma.length;i++){
						                        System.out.println(ma[i].getName());
						                }
						        }
						}
					-----------------------------------------------------------------------------

				## Get Access Modifiers : 
					import java.lang.reflect.*;
					class ReflectDemoMain{
					        public static void main(){}     
					        public static void demo(){}
					}

					class ReflectDemo2{
					        public static void main(String[]args){
					                Class cr = ReflectDemoMain.class;
					                Method[] m = cr.getDeclaredMethods();
					                int mod = m[0].getModifiers();
					                System.out.println(mod);
					                String s = (Modifier.toString(mod));
					                System.out.println(s);
					        }
					}



						import java.lang.reflect.*;
						class ReflectDemoMain{
						        private static void demo(int a,String s) throws Exception{}
						}

						class ReflectDemo2{
						        public static void main(String[]args){

						                Class cr = ReflectDemoMain.class;
						                Method[] m = cr.getDeclaredMethods();
						                int mod = m[0].getModifiers();

						                String s = (Modifier.toString(mod));
						                String s1 = m[0].getName();

						                Class rt = m[0].getReturnType();
						                Class[] pm = m[0].getParameterTypes();
						                Class[] nm = m[0].getExceptionTypes();
						                System.out.println("class "+cr.getName()+" {");
						                System.out.print("\t"+s+" "+rt.getName()+" "+s1+" (");
						                System.out.print(pm[0].getName()+", ");
						                System.out.print(pm[1].getName()+" ");
						                System.out.print(") throws ");
						                System.out.print(nm[0].getName()+" ");
						                System.out.println("{}");
						                System.out.println("}");
						        }

						}




							import java.util.*; 
							class FactoryMethodGenralized{
							        static HashMap<String,Object> hm = new HashMap<>();
							        synchronized public static Object getInstance(String s) throws Exception{
							                Object obj = hm.get(s);
							                if(obj != null ) return obj;
							                else{
							                        Class cl = Class.forName(s);
							                        obj = cl.newInstance();
							                        hm.put(s,obj);
							                }
							                return obj;
							        }
							        public static void main(String[] args){
							                try{
							                        String s = (String)FactoryMethodGenralized.getInstance("java.lang.String");
							                }catch(Exception e){}
							        }
							}



							###Generics : 

								class MyClass 	<T>{
									T t;
								}
								class MyMain{
									public static void main(String[] args){
										MyClass<Integer> m =new MyClass<Integer>();
										m.t=20;
										int k = m.t.intValue();
										System.out.println(k);
									}
								}


								class MyClass  {
								        public static <T> String getLength(T t){
								                return t.toString();
								        }
								}
								class MyMain{
								        public static void main(String[] args){
								                String k = MyClass.<String>getLength("Lucknow");
								                System.out.println(k);
								        }
								}
																	Optional
																	|
							## -> MyClass<Integer> m =new MyClass<Integer>();


								import java.util.*;
								class ColApi{
								        public static void main(String[]args){
								                ArrayList al = new ArrayList();
								                al.add(30);
								                al.add(3.5f);
								                al.add("Lucknow");
								                int y = ((Integer)al.get(0)).intValue();
								                Object obj = al.get(2);
								                System.out.println(y+" "+obj);
								        }
								}




						### Assertion : 

							class assertionDemo{
							        public static void main(String[] args){
							                int x = -10;
							                assert x>=0 : "X must be Greater then 0";
							                double d = Math.sqrt(x);
							                System.out.println(d);
							        }
							}

						To Run || To Enable : 
							For Class Loader : 	java -ea assertionDemo || java -enableassertions assertionDemo
							For JVM :			java -esa assertionDemo || java -enablesystemassertions assertionDemo

						To Disable : 
							For Class Loader :	java -da assertionDemo || java -disableassertions assertionDemo
							For JVM :			java -esa assertionDemo || java -enablesystemassertions assertionDemo



				##	Throwable class extends Object class, and Error & Exception extends Throwable 

						and Error  & IOExceptiob Class comes under unchecked Exception

						else all are comes under Checked Exception. 


					java -ea : mypkg... mpkg.MyClass 

					java -ea... MyClass



				###Logging : Mechanism to Store or display activity of particular process.

					Havig two types : Logger & Handler

						* Logger : it generates the Log of process.
						* Handler : it Handels the Log Generated by Logger and store into file , Console & Database.  

					* Level of Logging in Java: 

							1) Severe		|
											|
							2) Warning      |  Are Default level of Logging
											|
							3) Info         |

							4) Config    

							5) Fine

							6) Finner

							7) Finest




						import java.util.logging.*;
						class Loggr{
						        public static void main(String[]args){
						                Logger.getGlobal().info("My First Log");
						        }
						}



						import java.util.logging.*;
						class Loggr{
						        public static void main(String[]args){
						                Logger log = Logger.getGlobal();
						                log.setLevel(Level.INFO);
						                log.info("My First Log");
						        }
						}


					Output : 
						Mar 11, 2021 12:33:46 PM Loggr main
						INFO: Second Log



				import java.util.logging.*;
				class Loggr{
				        public static void main(String[]args){
				                Logger logg = Logger.getLogger("abc.xyz");
				                logg.setLevel(Level.WARNING);
				                logg.warning("This is First Warning");
				                Logger logg1 = Logger.getLogger("abc.xyz.acb");
				                logg1.warning("This is Second Warning");
				        }
				}


				import java.util.logging.*;
				class Loggr{
				        public static void main(String[]args){
				                Logger logg = Logger.getLogger("abc.xyz");
				                logg.setLevel(Level.WARNING);
				                logg.warning("This is First Warning");
				                Logger logg1 = Logger.getLogger("abc.xyz");
				                logg1.info("This is Second Warning");
				                if(logg==logg1) System.out.println("Same");
				        }
				}


				/usr/lib/jvm/java-11-openjdk-amd64/conf -> nano logging.properties (File where all the default properties are set for Logging).



				import java.util.logging.*;
				class Loggr{
				        public static void main(String[]args){
				                Logger logg = Logger.getLogger("abc.xyz");
				                logg.log(Level.FINE,"FIrst Fine Level Log");
				        }
				}

				Create a new .properties File in same directory.

				#For Handler
				handlers=java.util.logging.FileHandler,java.util.logging.ConsoleHandler
				.level = FINE

				#For Logger
				java.util.logging.FileHandler.level = FINE



				## File Handling  

				To Create Directory : 

					import java.io.*;
					class fileDemo{
					        public static void main(String[]args){
					                String H = System.getProperty("user.home");
					                String sep = File.separator;
					                File f = new File(H+sep+"fileDemo"+sep+"dirs");
					                f.mkdirs();
					        }
					}


				To Create Files

					import java.io.*;
					class fileDemo{
					        public static void main(String[]args){
					                String H = System.getProperty("user.home");
					                String sep = File.separator;
					                File f = new File(H+sep+"fileDemo");
					                try{
					                        f.createNewFile();
					                }catch(IOException ioe){
					                        ioe.printStackTrace();
					                }
					        }
					}


				To Read Data From a File :

					import java.io.*;
					class fileDemo{
					        public static void main(String[]args){
					                String H = System.getProperty("user.home");
					                String sep = File.separator;
					                File f = new File(H+sep+"fileDemo"+sep+"fileText.txt"); 
					                try{
					                        FileInputStream fis = new FileInputStream(f);
					                        int data=0;
					                        while((data=fis.read())!=-1){
					                                System.out.print((char)data);
					                        }
					                        fis.close();
					                }catch(IOException ioe){
					                        ioe.printStackTrace();
					                }
					        }
					}



				To Write Data into File : 

					import java.io.*;
					import java.util.*;
					class fileDemo{
					        public static void main(String[]args){
					                String H = System.getProperty("user.home");
					                String sep = File.separator;
					                File f = new File(H+sep+"fileDemo"+sep+"fileText.txt");
					                Scanner sc = new Scanner(System.in);
					                try{
					                        char data;
					                        FileOutputStream fos = new FileOutputStream(f);
					                        while((data=sc.next().charAt(0))!='#') {
					                                fos.write(data);
					                        }
					                        fos.close();
					                }catch(IOException ioe){
					                        ioe.printStackTrace();
					                }
					        }
					}


					
				##Input Stream <--------------------------(abstract Class)-----------------------> Output Stream
						
					Byte oriented																text oriented

					(1) FileInputStream  (2) FileOutputStream	 					(1) FileReader	(2) FileWriter 
							|						|										|				|
							|						|										|				|
						Flushable				Closeable								Flushable		Closeable
												Flushable								InputStream 	Flushable





					##  To Copy An Image :

						import java.io.*;
						import java.util.*;
						class ImageCopy{
						        public static void main(String[]args){
						                File f1 = new File("myimg.jpg");
						                File f2 = new File("myimgcpy.jpg");
						                try{
						                        FileInputStream fis = new FileInputStream(f1);
						                        FileOutputStream fos = new FileOutputStream(f2);
						                        int  b,count=0;
						                        while((b=fis.read())!=-1){
						                                fos.write(b);
						                                count=count+1;
						                        }
						                        System.out.println(count/1024 +" Kb");
						                        fos.close();
						                }catch(Exception e){
						                        e.printStackTrace();
						                }
						        }
						}





					## ToCopy Image Using BufferedInputStream & BufferedOutputStream

						import java.io.*;
						import java.util.*;
						class ImageCopy{
						        public static void main(String[]args){
						                File f1 = new File("myimg.jpg");
						                File f2 = new File("myimgcpy.jpg");
						                try{
						                        FileInputStream fis = new FileInputStream(f1);
						                        BufferedInputStream bis = new BufferedInputStream(fis,1024);
						                        FileOutputStream fos = new FileOutputStream(f2);
						                        BufferedOutputStream bos = new BufferedOutputStream(fos,1024);
						                        int  b,count=0;
						                        while((b=bis.read())!=-1){
						                                bos.write(b);
						                                count=count+1;
						                        }
						                        System.out.println(count/1024 +" Kb");
						                        bos.close();
						                }catch(Exception e){
						                        e.printStackTrace();
						                }
						        }
						}


				#Serializable : 


					MyClass.class -----> Class Loader ------> Method area ------> Heap Memory ------> Stack .


					import java.io.*;
					class MyClass implements Serializable {
					        private int age;
					        public MyClass(int x){ age=x; }
					        public String toString(){ return "Age is "+age; }
					}

					import java.io.*;
					class SerialDemo{
					        public static void main(String[]args){
					                MyClass m = new MyClass(20);
					                try{
					                        FileOutputStream fos = new FileOutputStream("abc.dat");
					                        ObjectOutputStream os = new ObjectOutputStream(fos);
					                        os.writeObject(m);
					                        FileInputStream fis = new FileInputStream("abc.dat");
					                        ObjectInputStream is = new ObjectInputStream(fis);
					                        MyClass m1 = (MyClass) is.readObject();
					                        System.out.println(m1.toString());
					                }catch(Exception e){
					                        e.printStackTrace();
					                }
					        }
					}


					* Here , Object (m) and (m1) is diffrent , where object is read from abc.dat

				Non-Access Modifier --->  Transient , When transient private int age; 
								then the state of the variable does'nt write in a file or can't transmit the state of the variable.




						## Data Input Stream :  to get the data from keyboard.

							import java.io.*;
							class DataFileInput{
							        public static void main(String[]args){
							                try{
							                        DataInputStream di = new DataInputStream(System.in);
							                        String in = di.readLine();
							                        File fis = new File("data.txt");
							                        FileOutputStream os=new FileOutputStream(fis);
							                        DataOutputStream dos=new DataOutputStream(os);
							                        dos.writeBytes(in);
							                        dos.close();
							                }catch(Exception e){
							                        e.printStackTrace();
							                }
							        }
							}


				

					##Creating Pdf Using JAVA

						import com.itextpdf.*;
						import com.itextpdf.text.*;
						import com.itextpdf.text.pdf.*;
						import java.io.*;
						public class MyPdfGen {
							public static void main(String[] args) {
								try {
									Document doc = new Document();
									doc.setPageSize(PageSize.A4);
									doc.setMargins(36,72,108,180);
									doc.setMarginMirroring(true);
									String home = System.getProperty("user.home");
									String sep = File.separator;
									File f = new File(home+sep+"mydemo.pdf");
									FileOutputStream fos = new FileOutputStream(f);
									PdfWriter writer = PdfWriter.getInstance(doc, fos);
									doc.open();
									doc.add(new Paragraph("This is My First Pdf Using iText API"));
									doc.close();
								}catch(Exception e) {
									e.printStackTrace();
								}
							}
						}


				##Collection API : The Collection API is a set of classes and interfaces that support operation on collections of objects.
																									 ------> TreeSet<E>
																						Implements   |
									 Extends				    	Extends		Set<E> -----------------------> HashSet<E>
						Iterator<E> ---------------> Collection<E> ------------>List<E>	----------------------> ArrayList<E>
																                Queue<E> ---------------------> PriorityQueue<E>

														     	Implements
													Map<K,V> --------------->HashMap<K,V>



						import java.util.*;
						import java.lang.*;
						class Arrlis{
						        public static void main(String[]args){
						                Collection<String> c = new ArrayList<>();
						                c.add("Jhon");
						                c.add("Damon");
						                c.add("Stefan");
						                /*Iterator it = c.iterator();
						                while(it.hasNext()){
						                		String s = (String)it.next();
						                        System.out.println(s);
						                }*/
						                for(String s : c){
						                	System.out.println(s);
						                }
						        }
						}


						import java.util.*;
						import java.lang.*;
						class Arrlis1{
						        public static void main(String[]args){
						                ArrayList<String> c = new ArrayList<>();
						                c.add("Jhon");
						                c.add("Damon");
						                c.add("Stefan");
						                if(c instanceof RandomAccess){
						                        for(int i=0;i<c.size();i++){
						                                System.out.println(c.get(i));
						                        }
						                }else System.out.println("False");
						        }
						}



						import java.util.*;
						import java.lang.*;
						class Arrlis1{
						        public static void main(String[]args){
						                LinkedList<String> c = new LinkedList<>();
						                c.add("Jhon");
						                c.add("Damon");
						                c.add("Stefan");
						                if(c instanceof RandomAccess){
						                        for(int i=0;i<c.size();i++){
						                                System.out.println(c.get(i));
						                        }
						                }else {
						                        for(int i=0;i<c.size();i++){
						                                System.out.println(c.get(i));
						                        }
						                }
						        }
						}


						

						##Legacy Classes  : 

							1) Vector						//These Methods are SYNCHRONISED or THREAD SAFE.
							2) HashTable
							3) Properties
							4) Enumuration
							5) Stack 	


							Enumeration :

								import java.util.*;
								class vectDemo{
								        public static void main(String[]args){
								                Vector<Integer> v1 = new Vector<Integer>();
								                v1.add(10);
								                v1.add(20);
								                v1.add(30);
								                Vector<Integer> v = new Vector<Integer>(v1);
								                Enumeration<Integer> e = v1.elements();
								                while(e.hasMoreElements()){
								                        System.out.println(e.nextElement());
								                }
								        }
								}


							Stack : 

							import java.util.*;
							class stakDemo{
							        public static void main(String[]args){
							                Stack<String> s = new Stack<>();
							                s.push("Lucknow");
							                s.push("Kanpur");
							                s.push("Delhi");
							                while(!s.empty()){
							                        System.out.println(s.pop());
							                }
							        }
							}


							Hashtable : 

								import java.util.*;
								class htDemo{
								        public static void main(String[]args){
								                Hashtable<String,String> ht = new Hashtable<>();
								                ht.put("name","Saquib");
								                ht.put("College","Integral");
								                ht.put("City","Lucknow");
								                System.out.println("Name : "+ht.get("name"));
								                System.out.println("College : "+ht.get("College"));
								                System.out.println("City : "+ht.get("City"));
								        }
								}


							
						Getting Data From Properties File :

							import java.util.*;
							import java.io.*;
							class PropertyDemo{
							        public static void main(String[]args){
							                Properties prop = new Properties();
							                String home = System.getProperty("user.home");
							                String pth = "/Code/Java/Collection/";
							                File f = new File(home+pth+"abc.properties");
							                try{
							                        FileInputStream fis = new FileInputStream(f);
							                        prop.load(fis);
							                        System.out.println(prop.getProperty("name"));
							                }catch(Exception e){
							                        e.printStackTrace();
							                }
							        }
							}



							Iterationg Over Properties File : 

								import java.util.*;
								import java.io.*;
								class PropertyDemo{
								        public static void main(String[]args){
								                Properties prop = new Properties();
								                String home = System.getProperty("user.home");
								                String pth = "/Code/Java/Collection/";
								                File f = new File(home+pth+"abc.properties");
								                try{
								                        FileInputStream fis = new FileInputStream(f);
								                        prop.load(fis);
								                        Enumeration<String> enum = (Enumeration<String>) prop.propertyNames();
								                        while(enum.hasMoreElements()) {
								                                String key = enum.nextElement();
								                                String value = prop.getProperty(key);
								                                System.out.println(key + " : " + value);
								                        }
								                }catch(Exception e){
								                        e.printStackTrace();
								                }
								        }
								}



								Storing Data into Property File : 

									import java.util.*;
									import java.io.*;
									class PropertyDemo1{
									        public static void main(String[]args){
									                Properties prop = new Properties();
									                String home = System.getProperty("user.home");
									                String pth = "/Code/Java/Collection/";
									                File f = new File(home+pth+"abc1.properties");
									                prop.setProperty("Name","Saquib");
									                prop.setProperty("City","Lucknow");
									                prop.setProperty("Age","25");
									                prop.setProperty("Branch","CSE");
									                try{
									                        FileOutputStream fos = new FileOutputStream(f);
									                        prop.store(fos,"Saquib Ahmed Detail");
									                        fos.close();
									                        Enumeration<String> e = (Enumeration<String>) prop.propertyNames();
									                        while(e.hasMoreElements()) {
									                                String key = e.nextElement();
									                                String value = prop.getProperty(key);
									                                System.out.println(key + " : " + value);
									                        }
									                }catch(Exception e){
									                        e.printStackTrace();
									                }
									        }
									}



								BitSet : 

									import java.util.BitSet;
									class bitSetDemo{
									        public static void main(String[]args){
									                BitSet b1 = new BitSet(16);
									                BitSet b2 = new BitSet(16);
									                for(int i=0;i<7;i++) {
									                        if((i%2) == 0) b1.set(i);
									                        if((i%3) == 0) b2.set(i);
									                }
									                System.out.println("First Bit(B1) : "+b1);
									                System.out.println("Second Bit(B2) : "+b2);

									                // AND bits
									                b2.and(b1);
									                long[] bits=b2.toLongArray();
									                //for(int i=0;i<bits.length;i++){
									                        System.out.println("B2 & B1 Array : "+bits[0]);
									                //}
									                System.out.println("B2 & B1 : "+b2.toString());

									                // OR bits
									                b2.or(b1);
									                System.out.println("B2 || B1 :"+b2);

									                // XOR bits
									                b2.xor(b1);
									                System.out.println("B2 ^ B1 : "+b2);
									        }
									}




								HashMap in Java : 

											  -----> HashMap : Unsorted and Stored on the basis of hashfunction f(n).
											  |	
									Map -----> 
											  |
											  -----> TreeMap : Sorted and Stored on the basis of Key and in Increasing Order of the key.



								import java.util.*;
								class mapDemo{
								        public static void main(String[]args){
								                HashMap<Integer,String>hm = new HashMap<Integer,String>();
								                hm.put(1,"Mahesh");
								                hm.put(2,"Suresh");
								                hm.put(3,"kalpesh");
								                for(int i=1;i<=hm.size();i++){
								                        System.out.println(i+" "+hm.get(i));
								                }
								        }
								}


							Using Iterator we are Getting Values in Set and Map : 

								import java.util.*;
								class mapDemo{
								        public static void main(String[]args){
								                HashMap<Integer,String>hm = new HashMap<Integer,String>();
								                hm.put(8,"Mahesh");
								                hm.put(7,"Suresh");
								                hm.put(6,"kalpesh");
								                hm.put(5,"Saquib");
								                hm.put(4,"Mujeeb");
								                hm.put(3,"Udbhav");
								                hm.put(2,"Junaid");
								                hm.put(1,"Rishav");
								/*              for(int i=1;i<=hm.size();i++){
								                        System.out.println(i+" "+hm.get(i));
								                }*/
								                /*Collection<String> k = hm.values();
								                for(String i : k){
								                        System.out.println(i);
								                }*/

								/*              Set<Map.Entry<Integer,String>> sme = hm.entrySet();
								                for(Map.Entry<Integer,String> i : sme){
								                        System.out.println(i.getKey()+" "+i.getValue());
								                }*/

								                Set<Integer>s=hm.keySet();
								                Iterator it = s.iterator();
								                while(it.hasNext()){
								                        System.out.println(hm.get(it.next()));
								                }
								        }
								}


						employee.properties 

							Mahesh  = /home/saquib/Code/Java/Collection/prop
							Suresh = /home/saquib/Code/Java/Collection/prop
							Kamal = /home/saquib/Code/Java/Collection/prop
							Rishav = /home/saquib/Code/Java/Collection/prop

						miniProjDemo.java

							import java.util.*;
							import java.io.*;
							class miniProjDemo{
							        public static void main(String[]args){
							                Properties prop = new Properties();
							                String home = System.getProperty("user.home");
							                String pth = "/Code/Java/Collection/";
							                File f = new File(home+pth+"employee.properties");
							                HashMap<String,Integer> hm = new HashMap<String,Integer>();

							                try{
							                        FileInputStream fis = new FileInputStream(f);
							                        prop.load(fis);
							                        Enumeration<String> e = (Enumeration<String>) prop.propertyNames();
							                        while(e.hasMoreElements()) {
							                                String name = e.nextElement();
							                                String  filePth = prop.getProperty(name);
							                                File f1 = new File(filePth+"/"+name+".properties");
							                                FileInputStream fis1 = new FileInputStream(f1);
							                                prop.load(fis1);
							                                String cty = prop.getProperty("City");
							                                if(hm.get(cty)!=null){
							                                        hm.put(cty,hm.get(cty)+1);
							                                }else{
							                                        hm.put(cty,1);
							                                }
							                        }

							                        hm.forEach((k,v)->{
							                                System.out.println(k+" "+v);
							                        });

							                }catch(Exception e){
							                        e.printStackTrace();
							                }
							        }
							}



						GetName of the City Input : 


							import java.util.*;
							import java.io.*;
							class miniProjDemo{
							        public static void main(String[]args){
							                Properties prop = new Properties();
							                String home = System.getProperty("user.home");
							                String pth = "/Code/Java/Collection/";
							                File f = new File(home+pth+"employee.properties");
							                //HashMap<String,Integer> hm = new HashMap<String,Integer>();
							                ArrayList<String> employeeName = new ArrayList<String>();
							                Scanner sc = new Scanner(System.in);
							                try{
							                        FileInputStream fis = new FileInputStream(f);
							                        prop.load(fis);
							                        System.out.print("Enter the City Name To Get Member : ");
							                        String cty = sc.nextLine();
							                        Enumeration<String> e = (Enumeration<String>) prop.propertyNames();
							                        while(e.hasMoreElements()) {
							                                String name = e.nextElement();
							                                String  filePth = prop.getProperty(name);
							                                File f1 = new File(filePth+"/"+name+".properties");
							                                FileInputStream fis1 = new FileInputStream(f1);
							                                prop.load(fis1);
							                                String EmpCty = prop.getProperty("City");
							                                if(cty.equals(EmpCty)){
							                                        String empName = prop.getProperty("Name");
							                                        employeeName.add(empName);
							                                }
							                        }

							                        for(String i : employeeName){
							                                System.out.println(i);
							                        }

							                }catch(Exception e){
							                        e.printStackTrace();
							                }
							        }
							}




							how to make symbol table :

								gcc -o sy -Wa,-as=symbol.sym,-L symbol.c



						Queue && PriorityQueue :

							In Queue :

							public abstract boolean add(E);  ---> if not added it will throw exception 							
							public abstract boolean offer(E);   ----> return false if now added

							public abstract E remove();		-----> throw exception if not removed
							public abstract E poll();		-----> 

							public abstract E element();
							public abstract E peek();



							import java.util.*;
							class pQue{
							        public static void main(String[]args){
							                Queue<String> q = new PriorityQueue<>();
							                q.offer("Lucknow");
							                q.offer("Kanpur");
							                q.offer("Delhi");
							                Iterator<String> it = q.iterator();
							                while(it.hasNext()){
							                        System.out.println(it.next());
							                }
							                System.out.println();
							        }
							}





							
						## In Java Main Class Can be Overloaded.

							class A{
						        public static void main(String[]args){
					                A a = new A();
					                int y = a.main(2);
					                System.out.println(y);
						        }
						        int main(int x){
						            return x*x;
						        }
							}


							Function & Method 

								if a function is in class then it is called METHOD.

								else it is called Function.



						
